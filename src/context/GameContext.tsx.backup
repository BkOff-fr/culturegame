'use client'

import { createContext, useContext, useState, useEffect, useCallback, ReactNode } from 'react';
import { useAuth } from './AuthContext';

// Types pour le contexte Game (REST API only)
interface GameState {
  id: string;
  roomCode: string;
  status: 'WAITING' | 'IN_PROGRESS' | 'FINISHED' | 'PAUSED';
  mode: 'SINGLE' | 'MULTIPLAYER' | 'TEAM' | 'TOURNAMENT';
  settings: any;
  currentQuestionIndex: number;
  players: Array<{
    id: string;
    user: {
      id: string;
      username: string;
      avatar?: string;
    };
    score: number;
    streak: number;
    position?: number;
    teamId?: string;
  }>;
  lives?: number;
  teamA?: string[];
  teamB?: string[];
  startedAt?: Date;
  endedAt?: Date;
  host: {
    id: string;
    username: string;
  };
}

interface CurrentQuestion {
  id: string;
  text: string;
  type: string;
  options?: string[];
  correctAnswer?: any;
  timeLimit: number;
  points: number;
  category?: string;
  imageUrl?: string;
}

interface QuestionResult {
  questionId: string;
  results: Array<{
    playerId: string;
    username: string;
    answer: any;
    correct: boolean;
    points: number;
    timeSpent: number;
  }>;
}

interface ChatMessageData {
  id: string;
  userId: string;
  username: string;
  message: string;
  type: 'PREDEFINED' | 'CUSTOM';
  timestamp: number;
  createdAt: Date;
}

interface GameContextType {
  gameState: GameState | null;
  currentQuestion: CurrentQuestion | null;
  questionResults: QuestionResult[] | null;
  messages: ChatMessageData[];
  isHost: boolean;
  loading: boolean;
  error: string | null;

  // Actions
  joinGame: (roomCode: string) => Promise<boolean>;
  leaveGame: (roomCode: string) => Promise<void>;
  markReady: (roomCode: string) => Promise<void>;
  startGame: (roomCode: string) => Promise<void>;
  submitAnswer: (roomCode: string, questionId: string, answer: any, timeSpent: number) => Promise<void>;
  sendMessage: (roomCode: string, message: string, type?: 'PREDEFINED' | 'CUSTOM') => Promise<void>;
  refreshGameState: () => Promise<void>;
  recoverGame: () => Promise<void>;
}

const GameContext = createContext<GameContextType | null>(null);

export const useGame = () => {
  const context = useContext(GameContext);
  if (!context) {
    throw new Error('useGame must be used within a GameProvider');
  }
  return context;
};

export const GameProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [gameState, setGameState] = useState<GameState | null>(null);
  const [currentQuestion, setCurrentQuestion] = useState<CurrentQuestion | null>(null);
  const [questionResults, setQuestionResults] = useState<QuestionResult[] | null>(null);
  const [messages, setMessages] = useState<ChatMessageData[]>([]);
  const [isHost, setIsHost] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const { user } = useAuth();

  // Fonction utilitaire pour les appels API
  const apiCall = useCallback(async (endpoint: string, options: RequestInit = {}) => {
    try {
      const response = await fetch(endpoint, {
        ...options,
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
          ...options.headers,
        },
      });

      if (!response.ok) {
        throw new Error(`API Error: ${response.status}`);
      }

      return await response.json();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      throw err;
    }
  }, []);

  // Rejoindre un jeu
  const joinGame = useCallback(async (roomCode: string): Promise<boolean> => {
    setLoading(true);
    setError(null);

    try {
      const data = await apiCall('/api/games/join', {
        method: 'POST',
        body: JSON.stringify({ roomCode }),
      });

      if (data.game) {
        setGameState(data.game);
        setIsHost(!!(data.game?.hostId && user?.id && data.game.hostId === user.id));
        return true;
      }
      return false;
    } catch (err) {
      console.error('Error joining game:', err);
      return false;
    } finally {
      setLoading(false);
    }
  }, [user?.id, apiCall]);

  // Quitter un jeu
  const leaveGame = useCallback(async (roomCode: string) => {
    setLoading(true);
    setError(null);

    try {
      await apiCall('/api/games/leave', {
        method: 'POST',
        body: JSON.stringify({ roomCode }),
      });

      setGameState(null);
      setCurrentQuestion(null);
      setQuestionResults(null);
      setMessages([]);
      setIsHost(false);
    } catch (err) {
      console.error('Error leaving game:', err);
    } finally {
      setLoading(false);
    }
  }, [apiCall]);

  // Marquer comme prêt
  const markReady = useCallback(async (roomCode: string) => {
    setLoading(true);
    setError(null);

    try {
      const data = await apiCall('/api/games/ready', {
        method: 'POST',
        body: JSON.stringify({ roomCode }),
      });

      if (data.game) {
        setGameState(data.game);
      }
    } catch (err) {
      console.error('Error marking ready:', err);
    } finally {
      setLoading(false);
    }
  }, [apiCall]);

  // Démarrer le jeu
  const startGame = useCallback(async (roomCode: string) => {
    setLoading(true);
    setError(null);

    try {
      if (!gameState?.id) throw new Error('No game id');
      const data = await apiCall(`/api/games/${gameState.id}/start`, {
        method: 'POST',
      });

      if (data.game) {
        setGameState(data.game);
      }
      if (data.question) {
        setCurrentQuestion(data.question);
      }
    } catch (err) {
      console.error('Error starting game:', err);
    } finally {
      setLoading(false);
    }
  }, [apiCall, gameState?.id]);

  // Soumettre une réponse
  const submitAnswer = useCallback(async (roomCode: string, questionId: string, answer: any, timeSpent: number) => {
    setLoading(true);
    setError(null);

    try {
      const data = await apiCall('/api/games/answer', {
        method: 'POST',
        body: JSON.stringify({ roomCode, questionId, answer, timeSpent }),
      });

      if (data.nextQuestion) {
        setCurrentQuestion(data.nextQuestion);
      } else if (data.results) {
        setQuestionResults(data.results);
      }

      if (data.game) {
        setGameState(data.game);
      }
    } catch (err) {
      console.error('Error submitting answer:', err);
    } finally {
      setLoading(false);
    }
  }, [apiCall]);

  // Envoyer un message
  const sendMessage = useCallback(async (roomCode: string, message: string, type: 'PREDEFINED' | 'CUSTOM' = 'CUSTOM') => {
    try {
      const data = await apiCall('/api/games/message', {
        method: 'POST',
        body: JSON.stringify({ roomCode, message, type }),
      });

      if (data.message) {
        setMessages(prev => [...prev, data.message]);
      }
    } catch (err) {
      console.error('Error sending message:', err);
    }
  }, [apiCall]);

  // Rafraîchir l'état du jeu
  const refreshGameState = useCallback(async () => {
    if (!gameState?.roomCode) return;

    try {
      const params = new URLSearchParams({ roomCode: gameState.roomCode });
      const data = await apiCall(`/api/games/status?${params.toString()}`);

      if (data.game) {
        setGameState(data.game);
      }
      if (data.question) {
        setCurrentQuestion(data.question);
      }
      if (data.messages) {
        setMessages(data.messages);
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err);
      if (message.includes('404')) {
        setGameState(null);
        setCurrentQuestion(null);
        setQuestionResults(null);
        setMessages([]);
        setIsHost(false);
      } else {
        console.error('Error refreshing game state:', err);
      }
    }
  }, [gameState?.roomCode, apiCall]);

  // Récupérer un jeu en cours
  const recoverGame = useCallback(async () => {
    if (!user) return;

    try {
      const data = await apiCall('/api/games/recover');

      if (data.game) {
        setGameState(data.game);
        setIsHost(!!(data.game?.hostId && user?.id && data.game.hostId === user.id));

        if (data.question) {
          setCurrentQuestion(data.question);
        }
        if (data.messages) {
          setMessages(data.messages);
        }
      }
    } catch (err) {
      console.error('Error recovering game:', err);
    }
  }, [user, apiCall]);

  // Auto-récupération au montage du composant
  useEffect(() => {
    if (user) {
      recoverGame();
    }
  }, [user, recoverGame]);

  // Polling pour les mises à jour en temps réel (toutes les 2 secondes)
  useEffect(() => {
    if (!gameState || gameState.status === 'FINISHED') return;

    const interval = setInterval(() => {
      refreshGameState();
    }, 2000);

    return () => clearInterval(interval);
  }, [gameState, refreshGameState]);

  const value: GameContextType = {
    gameState,
    currentQuestion,
    questionResults,
    messages,
    isHost,
    loading,
    error,
    joinGame,
    leaveGame,
    markReady,
    startGame,
    submitAnswer,
    sendMessage,
    refreshGameState,
    recoverGame,
  };

  return (
    <GameContext.Provider value={value}>
      {children}
    </GameContext.Provider>
  );
};

export default GameContext;