// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

model User {
  id          String   @id @default(cuid())
  username    String   @unique
  email       String?  @unique
  avatar      String   @default("ðŸŽ­")
  passwordHash String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  gamesPlayed      GamePlayer[]
  questionsCreated Question[]
  achievements     UserAchievement[]
  friends          Friendship[] @relation("UserFriends")
  friendOf         Friendship[] @relation("FriendOf")
  profile          UserProfile?
  powerUps         UserPowerUp[]
  dailyAttempts    DailyChallengeAttempt[]
  reviewSessions   ReviewSession[]
  chatMessages     ChatMessage[]
  connections      PlayerConnection[]
  reactions        PlayerReaction[]
  challengeResponses MicroChallengeResponse[]

  @@map("users")
}

model Game {
  id          String   @id @default(cuid())
  roomCode    String   @unique
  hostId      String
  status      GameStatus @default(WAITING)
  mode        GameMode @default(CLASSIC)
  settings    Json     // Game settings (time limit, categories, etc.)
  currentQuestionIndex Int @default(0)
  lives       Int?     // For survival mode
  teamA       Json?    // For team mode
  teamB       Json?    // For team mode
  startedAt   DateTime?
  endedAt     DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  players       GamePlayer[]
  questions     GameQuestion[]
  powerUpUsages GamePowerUpUsage[]
  chatMessages  ChatMessage[]
  replay        GameReplay?
  connections   PlayerConnection[]
  roomState     GameRoomState?
  reactions     PlayerReaction[]
  microChallenges MicroChallenge[]

  @@index([status, createdAt])
  @@index([hostId])
  @@index([roomCode])
  @@index([roomCode, status])
  @@index([hostId, status])
  @@map("games")
}

model GamePlayer {
  id       String @id @default(cuid())
  gameId   String
  userId   String
  score    Int    @default(0)
  streak   Int    @default(0)
  position Int?   // Final position in the game
  teamId   String? // For team mode (A or B)

  // Relations
  game          Game               @relation(fields: [gameId], references: [id], onDelete: Cascade)
  user          User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  answers       PlayerAnswer[]
  powerUpUsages GamePowerUpUsage[]

  @@unique([gameId, userId])
  @@index([gameId])
  @@index([userId])
  @@index([userId, score])
  @@map("game_players")
}

model Question {
  id          String      @id @default(cuid())
  type        QuestionType
  question    String
  data        Json        // Question data (answers, correct answer, etc.)
  category    String
  difficulty  Difficulty  @default(MEDIUM)
  points      Int         @default(100)
  timeLimit   Int         @default(30)
  isPublic    Boolean     @default(false)
  createdById String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  // Relations
  createdBy   User?       @relation(fields: [createdById], references: [id])
  gameQuestions GameQuestion[]
  
  @@index([category, difficulty])
  @@index([isPublic, category])
  @@index([createdById])
  @@map("questions")
}

model GameQuestion {
  id         String @id @default(cuid())
  gameId     String
  questionId String
  order      Int

  // Relations
  game          Game               @relation(fields: [gameId], references: [id], onDelete: Cascade)
  question      Question           @relation(fields: [questionId], references: [id])
  answers       PlayerAnswer[]
  powerUpUsages GamePowerUpUsage[]

  @@unique([gameId, questionId])
  @@index([gameId, order])
  @@map("game_questions")
}

model PlayerAnswer {
  id             String   @id @default(cuid())
  gamePlayerId   String
  gameQuestionId String
  answer         Json     // Player's answer
  isCorrect      Boolean
  pointsEarned   Int
  timeSpent      Int      // Time in seconds
  answeredAt     DateTime @default(now())
  
  // Relations
  gamePlayer     GamePlayer   @relation(fields: [gamePlayerId], references: [id], onDelete: Cascade)
  gameQuestion   GameQuestion @relation(fields: [gameQuestionId], references: [id], onDelete: Cascade)
  
  @@unique([gamePlayerId, gameQuestionId])
  @@index([gamePlayerId])
  @@index([isCorrect, pointsEarned])
  @@map("player_answers")
}

model Achievement {
  id          String @id @default(cuid())
  name        String @unique
  description String
  icon        String
  condition   Json   // Conditions to unlock this achievement
  points      Int    @default(0)
  
  // Relations
  users       UserAchievement[]
  
  @@map("achievements")
}

model UserAchievement {
  id            String   @id @default(cuid())
  userId        String
  achievementId String
  unlockedAt    DateTime @default(now())
  
  // Relations
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)
  
  @@unique([userId, achievementId])
  @@map("user_achievements")
}

model Friendship {
  id         String   @id @default(cuid())
  userId     String
  friendId   String
  status     FriendshipStatus @default(PENDING)
  createdAt  DateTime @default(now())
  
  // Relations
  user       User @relation("UserFriends", fields: [userId], references: [id], onDelete: Cascade)
  friend     User @relation("FriendOf", fields: [friendId], references: [id], onDelete: Cascade)
  
  @@unique([userId, friendId])
  @@map("friendships")
}

model Leaderboard {
  id        String   @id @default(cuid())
  userId    String
  category  String   // "all_time", "weekly", "monthly", etc.
  score     Int
  rank      Int
  period    String   // "2024-01", "2024-W01", etc.
  updatedAt DateTime @updatedAt
  
  @@unique([userId, category, period])
  @@index([category, period, rank])
  @@index([userId, category])
  @@map("leaderboards")
}

enum GameStatus {
  WAITING
  STARTING
  IN_PROGRESS
  FINISHED
  CANCELLED
}

enum QuestionType {
  MULTIPLE_CHOICE
  TRUE_FALSE
  TEXT_INPUT
  ORDERING
  SLIDER
  IMAGE_ZONES
  MATCHING
  SPEED
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
  EXPERT
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

// New models for enhanced features

model PowerUp {
  id          String   @id @default(cuid())
  type        PowerUpType @unique
  name        String   @unique
  description String
  icon        String
  cost        Int      @default(100)
  createdAt   DateTime @default(now())

  // Relations
  userPowerUps UserPowerUp[]
  usages       GamePowerUpUsage[]

  @@map("power_ups")
}

model UserPowerUp {
  id        String   @id @default(cuid())
  userId    String
  powerUpId String
  quantity  Int      @default(0)

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  powerUp   PowerUp  @relation(fields: [powerUpId], references: [id], onDelete: Cascade)

  @@unique([userId, powerUpId])
  @@map("user_power_ups")
}

model GamePowerUpUsage {
  id         String   @id @default(cuid())
  gameId     String
  playerId   String
  powerUpId  String
  questionId String
  usedAt     DateTime @default(now())

  game       Game         @relation(fields: [gameId], references: [id], onDelete: Cascade)
  player     GamePlayer   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  powerUp    PowerUp      @relation(fields: [powerUpId], references: [id])
  question   GameQuestion @relation(fields: [questionId], references: [id])

  @@map("game_power_up_usages")
}

model UserProfile {
  id            String   @id @default(cuid())
  userId        String   @unique
  avatar        Json     // {shape, color, accessories, background}
  banner        String?
  title         String?
  theme         String   @default("dark")
  coins         Int      @default(1000)
  experience    Int      @default(0)
  level         Int      @default(1)
  eloRating     Int      @default(1200)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}

model DailyChallenge {
  id          String   @id @default(cuid())
  date        DateTime @unique
  questions   Json     // Array of question IDs
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  attempts    DailyChallengeAttempt[]

  @@map("daily_challenges")
}

model DailyChallengeAttempt {
  id            String   @id @default(cuid())
  challengeId   String
  userId        String
  score         Int
  completedAt   DateTime @default(now())
  answers       Json     // Detailed answers

  challenge     DailyChallenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  user          User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([challengeId, userId])
  @@map("daily_challenge_attempts")
}

model GameReplay {
  id         String   @id @default(cuid())
  gameId     String   @unique
  data       Json     // Complete game state history
  createdAt  DateTime @default(now())

  game       Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@map("game_replays")
}

model ReviewSession {
  id         String   @id @default(cuid())
  userId     String
  questions  Json     // Questions to review
  progress   Json     // Review progress
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("review_sessions")
}

model ChatMessage {
  id         String      @id @default(cuid())
  gameId     String
  userId     String
  message    String
  type       MessageType @default(PREDEFINED)
  createdAt  DateTime    @default(now())

  game       Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("chat_messages")
}

enum PowerUpType {
  FIFTY_FIFTY
  FREEZE_TIME
  DOUBLE_POINTS
  SKIP_QUESTION
  HINT
}

enum MessageType {
  PREDEFINED
  CUSTOM
  SYSTEM
}

enum GameMode {
  CLASSIC
  SURVIVAL
  DUEL
  MARATHON
  TEAM
  TEAM_SURVIVAL
  DAILY
}

// New models for real-time architecture improvements

model PlayerConnection {
  id          String   @id @default(cuid())
  userId      String
  gameId      String?
  socketId    String   @unique
  connectedAt DateTime @default(now())
  lastSeen    DateTime @default(now())
  userAgent   String?
  ipAddress   String?

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  game        Game?    @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@index([gameId, userId])
  @@index([socketId])
  @@index([userId, connectedAt])
  @@map("player_connections")
}

model GameRoomState {
  id                   String   @id @default(cuid())
  gameId               String   @unique
  lastActivity         DateTime @default(now())
  playerCount          Int      @default(0)
  currentQuestionIndex Int      @default(0)
  status               GameStatus
  roomData             Json?    // Serialized room state for persistence

  game                 Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@index([lastActivity])
  @@index([status, lastActivity])
  @@map("game_room_states")
}

model PlayerReaction {
  id          String   @id @default(cuid())
  gameId      String
  userId      String
  reaction    String   // ðŸ”¥, ðŸ˜°, ðŸ¤”, ðŸ’ª, ðŸ˜…, ðŸŽ¯, âš¡
  questionId  String?  // Optionnel, pour les rÃ©actions pendant une question
  timestamp   DateTime @default(now())
  expiresAt   DateTime // Les rÃ©actions expirent aprÃ¨s quelques secondes

  game        Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([gameId, timestamp])
  @@index([questionId, timestamp])
  @@index([expiresAt])
  @@map("player_reactions")
}

model MicroChallenge {
  id          String   @id @default(cuid())
  gameId      String
  type        String   // 'poll', 'prediction', 'quickTrivia'
  question    String
  options     Json?    // Pour les sondages/prÃ©dictions
  correctAnswer String? // Pour les trivias
  status      String   @default("ACTIVE") // ACTIVE, COMPLETED
  createdAt   DateTime @default(now())
  expiresAt   DateTime

  game        Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  responses   MicroChallengeResponse[]

  @@index([gameId, status])
  @@index([expiresAt])
  @@map("micro_challenges")
}

model MicroChallengeResponse {
  id            String   @id @default(cuid())
  challengeId   String
  userId        String
  response      String
  submittedAt   DateTime @default(now())

  challenge     MicroChallenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([challengeId, userId])
  @@map("micro_challenge_responses")
}
